# CSP-Class-Schediling
CSP Class Scheduling problem solved for Intellectual Systems class


## Вказівки щодо виконання коду

Запуск коду вимагає лише встановлення пакету **tabulate**

Поточні параметри в коді:
- Кількість днів = 5
- Занять у день = 4
- Кількість вчителів = 4
- Кількість груп = 3
- Кількість аудиторій = 5
- Кількість предметів = 6
- Предметів на групу = 4
- Предметів на викладача = 4

В коді присутнє рандомне перемішування  деяких змінних, тому результати виконання можуть відрізнятися.

В деяких випадках виконання може займати дуже тривалий час (адже відбувається рекурсивний перебір розв'язків), 
тому краще не чекати закінчення, а запустити заново. Розклад може бути побудовний як за долю секунди, так і за десятки хвилин, 
залежно від випадкового порядку вибору значень в задачі. Рандом необхідний, щоб уникнути довгих одноманітних обчислень. Якщо зменшити деякі
параметри (наприклад кількість предметів на групу), то код буде виконуватись швидше.

## Опис виконаних завдань

Всі обмеження на задачу залишаються такими ж, як і з попередньої лабораторної (генетичний алгоритм).

### Використані евристики:
✅**Minimum Remaining Values** - вибираю групу для заняття, яке має найбільшу кількість назначених _сусідів_ 
(занять, що йдуть в цей самий час, але в іншої групи/викладача)

✅**Degree Heuristic** - вибираю заняття з найбільшим _степенем_ - тобто те, яке має найбільше незаповнених _сусідів_, 
а тому й залучене в найбільшу кількість **constraints**.

✅**Least Constraining Value Heuristic** - вибираються вже не заняття (змінні), а викладачі/предмети/аудиторії (значення) таким чином,
щоб вибір викладача для однієї групи накладав найменше обмежень (constraints) для іншої групи.

✅**Forward Checking** - при виборі значень відбувається перевірка, чи не поламають ці значення відповідні обмеження у майбутньому 
(аналогічно відкиданню неприйнятних значеннь з домену змінної).

✅**Constraint Propagation** - додається можливість відкидання значень змінної А, що приводять до неприйнятності всіх значень змінної Б, 
де А та Б поєднані _аркою_. **Не використовував цей метод при бенчмаркінгу**, адже він може принести користь лише при більших 
значеннях параметрів, що значно уповільнюють бенчмаркінг.

## Результати бенчмаркінгу

Кожен варіант алгоритму було запущено 100 разів.
Якщо перевірка на обмеження була виконана більше мільйона разів (кілька десятків секунд), то запуск рахується як **infinite**
та його тривалість не враховується у швидкість (time per run)

| - | Simple backtraking  | Minimum Remaining Values | Degree Heuristic | LCV Heuristic | Forward Checking |
| - | ------------- | ------------- | - | - | - |
| Time per run (s.) | 1.787  | 1.15  | 0.82 | - | - |
| Number of infinite runs | 69  | 66 | 94 | - | - |

Як можна бачити найкраще себе показує 
